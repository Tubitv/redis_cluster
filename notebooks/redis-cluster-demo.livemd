<!-- livebook:{"file_entries":[{"name":"hash-slots.png","type":"attachment"},{"name":"tree-diagram.png","type":"attachment"}],"persist_outputs":true} -->

# Redis Cluster Demo

```elixir
Mix.install([
  {:redis_cluster, path: Path.expand("../", __DIR__)},
  {:kino_redis_cluster, path: Path.expand("../kino_redis_cluster", __DIR__)}
])
```

## Summary

Redis is an in-memory key-value store. In it's most basic form, it has a single server that contains all the key-value pairs. It can optionally have up to 5 read replicas (at least for AWS ElastiCache). Expanding beyond this requires cluster mode, which introduces some new complexity.

## Setup

To demonstrate, let's first start up a cluster. 
It will have 12 nodes running from ports 7000-7011. 
There will be 4 masters with 2 replicas each. 
You must have `redis-cli` installed first (`brew install redis`).

```elixir
exec = Path.expand("../scripts/redis_cluster.exs", __DIR__)

{output, 0} = System.cmd(exec, ~w[start --port 7000 --replicas-per-master 2])

IO.puts(output)
```

<!-- livebook:{"output":true} -->

```
Starting Redis on port 7000
Starting Redis on port 7001
Starting Redis on port 7002
Starting Redis on port 7003
Starting Redis on port 7004
Starting Redis on port 7005
Starting Redis on port 7006
Starting Redis on port 7007
Starting Redis on port 7008
Starting Redis on port 7009
Starting Redis on port 7010
Starting Redis on port 7011
Waiting for Redis instances to start...
Creating Redis Cluster with nodes: ["127.0.0.1:7000", "127.0.0.1:7001", "127.0.0.1:7002", "127.0.0.1:7003", "127.0.0.1:7004", "127.0.0.1:7005", "127.0.0.1:7006", "127.0.0.1:7007", "127.0.0.1:7008", "127.0.0.1:7009", "127.0.0.1:7010", "127.0.0.1:7011"]

```

<!-- livebook:{"output":true} -->

```
:ok
```

Next, we connect to the cluster.

```elixir
config = %RedisCluster.Configuration{
  host: "localhost",
  port: 7000,
  name: Test.Redis,
  registry: Test.Redis.Registry__,
  pool: Test.Redis.Pool__,
  cluster: Test.Redis.Cluster__,
  shard_discovery: Test.Redis.ShardDiscovery__,
  pool_size: 3
}

pid = case RedisCluster.Cluster.start_link(config) do
  {:ok, pid} -> pid
  {:error, {:already_started, pid}} -> pid
end
```

<!-- livebook:{"output":true} -->

```
#PID<0.294.0>
```

<!-- livebook:{"output":true} -->

```

11:21:45.021 [debug] Discovering shards for Elixir.Test.Redis

11:21:45.053 [debug] Found cluster info
Slot Start | Slot End | Host      | Port | Role    | Health
---------- | -------- | --------- | ---- | ------- | ------
0          | 5460     | 127.0.0.1 | 7000 | replica | online
0          | 5460     | 127.0.0.1 | 7003 | replica | online
0          | 5460     | 127.0.0.1 | 7006 | master  | online
0          | 5460     | 127.0.0.1 | 7010 | replica | online
0          | 5460     | 127.0.0.1 | 7011 | replica | online
5461       | 10922    | 127.0.0.1 | 7001 | replica | online
5461       | 10922    | 127.0.0.1 | 7007 | replica | online
5461       | 10922    | 127.0.0.1 | 7009 | master  | online
10923      | 16383    | 127.0.0.1 | 7002 | replica | online
10923      | 16383    | 127.0.0.1 | 7004 | master  | online
10923      | 16383    | 127.0.0.1 | 7005 | replica | online
10923      | 16383    | 127.0.0.1 | 7008 | replica | online

```

This starts a supervisor that watches connection pools, among other things. 
Re-run the following cell if you don't see all the connections.
It takes a moment to discover them all.

```elixir
Kino.Process.render_sup_tree(pid, direction: :left_right)
```

<!-- livebook:{"output":true} -->

```mermaid
graph LR;
2(Test.Redis.Pool__):::supervisor ---> 23(#PID<0.329.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 35(#PID<0.367.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 15(#PID<0.321.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 9(#PID<0.303.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 37(#PID<0.319.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 6(#PID<0.347.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 36(#PID<0.323.0>):::worker
17(#PID<0.333.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 31(#PID<0.327.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 7(#PID<0.351.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 20(#PID<0.357.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 24(#PID<0.311.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 22(#PID<0.337.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 3(#PID<0.341.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 18(#PID<0.355.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 22(#PID<0.337.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 5(#PID<0.339.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 28(#PID<0.371.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 32(#PID<0.359.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 38(#PID<0.361.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 26(#PID<0.363.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 29(#PID<0.301.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 35(#PID<0.367.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 26(#PID<0.363.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 20(#PID<0.357.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 17(#PID<0.333.0>):::worker
13(#PID<0.313.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 14(#PID<0.335.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 36(#PID<0.323.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 21(#PID<0.317.0>):::worker
4(#PID<0.315.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 28(#PID<0.371.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 27(#PID<0.345.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 24(#PID<0.311.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 13(#PID<0.313.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 23(#PID<0.329.0>):::worker
11(#PID<0.353.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 11(#PID<0.353.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 27(#PID<0.345.0>):::worker
14(#PID<0.335.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
15(#PID<0.321.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 10(#PID<0.349.0>):::worker
12(#PID<0.325.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 38(#PID<0.361.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 31(#PID<0.327.0>):::worker
19(#PID<0.307.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
0(Test.Redis.Cluster__):::root ---> 2(Test.Redis.Pool__):::supervisor
39(Test.Redis.Registry__):::supervisor ---> 40(Test.Redis.Registry__.PIDPartition0):::worker
5(#PID<0.339.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
9(#PID<0.303.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 33(#PID<0.365.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 25(#PID<0.343.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 29(#PID<0.301.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 25(#PID<0.343.0>):::worker
0(Test.Redis.Cluster__):::root ---> 1(Test.Redis.ShardDiscovery__):::worker
0(Test.Redis.Cluster__):::root ---> 39(Test.Redis.Registry__):::supervisor
2(Test.Redis.Pool__):::supervisor ---> 12(#PID<0.325.0>):::worker
16(#PID<0.369.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 34(#PID<0.309.0>):::worker
7(#PID<0.351.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 4(#PID<0.315.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 34(#PID<0.309.0>):::worker
6(#PID<0.347.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 30(#PID<0.331.0>):::worker
3(#PID<0.341.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 19(#PID<0.307.0>):::worker
40(Test.Redis.Registry__.PIDPartition0):::worker -..- 30(#PID<0.331.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 21(#PID<0.317.0>):::worker
8(#PID<0.305.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
10(#PID<0.349.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 37(#PID<0.319.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 33(#PID<0.365.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 16(#PID<0.369.0>):::worker
2(Test.Redis.Pool__):::supervisor ---> 8(#PID<0.305.0>):::worker
18(#PID<0.355.0>):::worker -..- 40(Test.Redis.Registry__.PIDPartition0):::worker
2(Test.Redis.Pool__):::supervisor ---> 32(#PID<0.359.0>):::worker
classDef root fill:#c4b5fd, stroke:#374151, stroke-width:4px, line-height:1.5em;
classDef supervisor fill:#c4b5fd, stroke:#374151, stroke-width:1px, line-height:1.5em;
classDef worker fill:#66c2a5, stroke:#374151, stroke-width:1px, line-height:1.5em;
classDef notstarted color:#777, fill:#d9d9d9, stroke:#777, stroke-width:1px, line-height:1.5em;
classDef ets fill:#a5f3fc, stroke:#374151, stroke-width:1px;


```

Then, we confirm the Redis cluster topology.

```elixir
config
|> RedisCluster.HashSlots.all_slots()
|> Enum.sort()
```

<!-- livebook:{"output":true} -->

```
[
  {RedisCluster.HashSlots, 0, 5460, :master, "127.0.0.1", 7006},
  {RedisCluster.HashSlots, 0, 5460, :replica, "127.0.0.1", 7000},
  {RedisCluster.HashSlots, 0, 5460, :replica, "127.0.0.1", 7003},
  {RedisCluster.HashSlots, 0, 5460, :replica, "127.0.0.1", 7010},
  {RedisCluster.HashSlots, 0, 5460, :replica, "127.0.0.1", 7011},
  {RedisCluster.HashSlots, 5461, 10922, :master, "127.0.0.1", 7009},
  {RedisCluster.HashSlots, 5461, 10922, :replica, "127.0.0.1", 7001},
  {RedisCluster.HashSlots, 5461, 10922, :replica, "127.0.0.1", 7007},
  {RedisCluster.HashSlots, 10923, 16383, :master, "127.0.0.1", 7004},
  {RedisCluster.HashSlots, 10923, 16383, :replica, "127.0.0.1", 7002},
  {RedisCluster.HashSlots, 10923, 16383, :replica, "127.0.0.1", 7005},
  {RedisCluster.HashSlots, 10923, 16383, :replica, "127.0.0.1", 7008}
]
```

![](files/tree-diagram.png)

## Smart Cells

Instead of writing the code, `kino_redis_cluster` provides some smart cells for working with Redis. 
The first cell is for opening a connection. It returns a `RedisCluster.Configuration` struct.

<!-- livebook:{"attrs":"eyJob3N0IjoibG9jYWxob3N0IiwibmFtZSI6IkxvY2FsQ2x1c3RlciIsInBvb2xfc2l6ZSI6IjIiLCJwb3J0IjoiNjM3OSIsInZhcmlhYmxlIjoiY29uZmlnIn0","chunks":null,"kind":"Elixir.Livebook.SmartCell.RedisCluster.Connect","livebook_object":"smart_cell"} -->

```elixir
name = "LocalCluster"

config = %RedisCluster.Configuration{
  name: String.to_atom(name),
  host: "localhost",
  port: 6379,
  pool_size: 2,
  registry: Module.concat([name, Registry]),
  pool: Module.concat([name, Pool]),
  cluster: Module.concat([name, Cluster]),
  shard_discovery: Module.concat([name, ShardDiscovery])
}

# Start the cluster only if not already started
case RedisCluster.Cluster.start_link(config) do
  {:ok, _pid} -> :ok
  {:error, {:already_started, _pid}} -> :ok
  {:error, reason} -> raise "Failed to start Redis cluster: #{inspect(reason)}"
end

config

```

<!-- livebook:{"output":true} -->

```

11:22:09.644 [debug] Discovering shards for LocalCluster

```

<!-- livebook:{"output":true} -->

```
%RedisCluster.Configuration{
  host: "localhost",
  port: 6379,
  name: :LocalCluster,
  registry: LocalCluster.Registry,
  cluster: LocalCluster.Cluster,
  pool: LocalCluster.Pool,
  shard_discovery: LocalCluster.ShardDiscovery,
  pool_size: 2,
  redis_module: Redix
}
```

The other smart cell provided is for running pipelines. 
These are a series of one or more commands sent to Redis in one batch. 
The response is a list of command results.
When writing commands in the pipeline, note that you can use Elixir string interpolation (`SET #{key} #{value}`) to inject your own variables.
By convention commands are uppercase, though they are case insensitive.

You may also specify the node role to target. 
Write commands must always go to a master node. 
Replicas may handle read commands, though they may return stale data if it hasn't synced with the master.
If you don't care what node, then you can pick "Any".

In cluster mode, Redis must know which node owns the appropriate data. 
This is the key it operates on. 
For example with the commanad `SET target-key "some value"`, `target-key` is they key you should use.
Some commands, like `PING` can be run on any node.
For these commands set the key to `:any`. 
This will pick a random node.

```elixir
my_key = "answer"
my_value = 42
```

<!-- livebook:{"output":true} -->

```
42
```

<!-- livebook:{"output":true} -->

```

11:22:09.665 [debug] Found cluster info
Slot Start | Slot End | Host      | Port | Role    | Health
---------- | -------- | --------- | ---- | ------- | ------
0          | 5460     | 127.0.0.1 | 6379 | master  | online
0          | 5460     | 127.0.0.1 | 6386 | replica | online
0          | 5460     | 127.0.0.1 | 6388 | replica | online
0          | 5460     | 127.0.0.1 | 6389 | replica | online
5461       | 10922    | 127.0.0.1 | 6380 | replica | online
5461       | 10922    | 127.0.0.1 | 6382 | replica | online
5461       | 10922    | 127.0.0.1 | 6383 | replica | online
5461       | 10922    | 127.0.0.1 | 6387 | master  | online
10923      | 16383    | 127.0.0.1 | 6381 | master  | online
10923      | 16383    | 127.0.0.1 | 6384 | replica | online
10923      | 16383    | 127.0.0.1 | 6385 | replica | online
10923      | 16383    | 127.0.0.1 | 6390 | replica | online

```

<!-- livebook:{"attrs":"eyJjb21tYW5kcyI6WyJTRVQgI3tteV9rZXl9ICN7bXlfdmFsdWV9IiwiR0VUICN7bXlfa2V5fSIsIklOQ1IgI3tteV9rZXl9IiwiR0VUICN7bXlfa2V5fSIsIkRFTCAje215X2tleX0iLCJHRVQgI3tteV9rZXl9Il0sImNvbmZpZ192YXJpYWJsZSI6ImNvbmZpZyIsImtleSI6IiN7bXlfa2V5fSIsInJvbGUiOiJtYXN0ZXIiLCJ2YXJpYWJsZSI6InJlc3VsdCJ9","chunks":null,"kind":"Elixir.Livebook.SmartCell.RedisCluster.Pipeline","livebook_object":"smart_cell"} -->

```elixir
# Redis Cluster Pipeline Commands
commands = [
  ["SET", "#{my_key}", "#{my_value}"],
  ["GET", "#{my_key}"],
  ["INCR", "#{my_key}"],
  ["GET", "#{my_key}"],
  ["DEL", "#{my_key}"],
  ["GET", "#{my_key}"]
]

result = RedisCluster.Cluster.pipeline(config, commands, "#{my_key}", [role: :master])

```

<!-- livebook:{"output":true} -->

```
["OK", "42", 43, "43", 1, nil]
```

Here are some example commands that are safe to send to any node.
Notice that you can get different results depending on the node you hit.

<!-- livebook:{"attrs":"eyJjb21tYW5kcyI6WyJQSU5HIiwiREJTSVpFIiwiVElNRSIsIkVDSE8gdGVzdCIsIkNMVVNURVIgS0VZU0xPVCBcInNvbWUga2V5XCIiLCJJTkZPIE1FTU9SWSJdLCJjb25maWdfdmFyaWFibGUiOiJjb25maWciLCJrZXkiOiI6YW55Iiwicm9sZSI6ImFueSIsInZhcmlhYmxlIjoicmVzdWx0In0","chunks":null,"kind":"Elixir.Livebook.SmartCell.RedisCluster.Pipeline","livebook_object":"smart_cell"} -->

```elixir
# Redis Cluster Pipeline Commands
commands = [
  ["PING"],
  ["DBSIZE"],
  ["TIME"],
  ["ECHO", "test"],
  ["CLUSTER", "KEYSLOT", "some key"],
  ["INFO", "MEMORY"]
]

result = RedisCluster.Cluster.pipeline(config, commands, :any, [role: :any])

```

<!-- livebook:{"output":true} -->

```
[
  "PONG",
  2,
  ["1754673738", "464784"],
  "test",
  11759,
  "# Memory\r\nused_memory:2581696\r\nused_memory_human:2.46M\r\nused_memory_rss:8388608\r\nused_memory_rss_human:8.00M\r\nused_memory_peak:2650320\r\nused_memory_peak_human:2.53M\r\nused_memory_peak_perc:97.41%\r\nused_memory_overhead:2484652\r\nused_memory_startup:2056960\r\nused_memory_dataset:97044\r\nused_memory_dataset_perc:18.49%\r\nallocator_allocated:2482688\r\nallocator_active:8388608\r\nallocator_resident:8388608\r\nallocator_muzzy:0\r\ntotal_system_memory:51539607552\r\ntotal_system_memory_human:48.00G\r\nused_memory_lua:31744\r\nused_memory_vm_eval:31744\r\nused_memory_lua_human:31.00K\r\nused_memory_scripts_eval:0\r\nnumber_of_cached_scripts:0\r\nnumber_of_functions:0\r\nnumber_of_libraries:0\r\nused_memory_vm_functions:32768\r\nused_memory_vm_total:64512\r\nused_memory_vm_total_human:63.00K\r\nused_memory_functions:344\r\nused_memory_scripts:344\r\nused_memory_scripts_human:344B\r\nmaxmemory:0\r\nmaxmemory_human:0B\r\nmaxmemory_policy:noeviction\r\nallocator_frag_ratio:1.00\r\nallocator_frag_bytes:0\r\nallocator_rss_ratio:1.00\r\nallocator_rss_bytes:0\r\nrss_overhead_ratio:1.00\r\nrss_overhead_bytes:0\r\nmem_fragmentation_ratio:3.38\r\nmem_fragmentation_bytes:5905920\r\nmem_not_counted_for_evict:128\r\nmem_replication_backlog:67684\r\nmem_total_replication_buffers:67680\r\nmem_replica_full_sync_buffer:0\r\nmem_clients_slaves:0\r\nmem_clients_normal:5504\r\nmem_cluster_links:23584\r\nmem_aof_buffer:128\r\nmem_allocator:libc\r\nmem_overhead_db_hashtable_rehashing:0\r\nactive_defrag_running:0\r\nlazyfree_pending_objects:0\r\nlazyfreed_objects:0\r\n"
]
```

## Hash Slots

In clustered mode, the key is run through a CRC-16 X-Modem function modulo 16,384. This gives a range of 0-16,383. This keyspace is split up among all the master nodes.

Let's query the cluster and see what this looks like.

```elixir
config
|> RedisCluster.HashSlots.all_slots()
|> Enum.filter(fn {_mod, _lo, _hi, role, _host, _port} -> role == :master end)
|> Enum.sort()
```

<!-- livebook:{"output":true} -->

```
[
  {RedisCluster.HashSlots, 0, 5460, :master, "127.0.0.1", 6379},
  {RedisCluster.HashSlots, 5461, 10922, :master, "127.0.0.1", 6387},
  {RedisCluster.HashSlots, 10923, 16383, :master, "127.0.0.1", 6381}
]
```

![](files/hash-slots.png)

<!-- livebook:{"break_markdown":true} -->

With a fresh cluster, we should have four ranges:

* 0-4095
* 4096-8191
* 8192-12,287
* 12,288-16,383

If a cluster adds and removes shards, these ranges can become fragmented. For simplicity in the examples, we'll stick with these nice ranges.

Now, let's take some arbitrary keys and see what they hash to.

```elixir
for key <- ~w[1 2 3 4 5] do
  slot = RedisCluster.Key.hash_slot(key)
  IO.puts("#{key} => #{slot}")
end
```

<!-- livebook:{"output":true} -->

```
1 => 9842
2 => 5649
3 => 1584
4 => 14039
5 => 9974
```

<!-- livebook:{"output":true} -->

```
[:ok, :ok, :ok, :ok, :ok]
```

Even though these keys are sequential numbers, the hashes are (ideally) randomly distributed. 
This ensures each of the nodes have roughly the same number of key-value pairs.
Let's put some data in the cluster to confirm.

```elixir
pairs = [
  {"1", "one"},
  {"2", "two"},
  {"3", "three"},
  {"4", "four"},
  {"5", "five"},
  {"6", "six"},
  {"7", "seven"},
  {"8", "eight"},
  {"9", "nine"},
  {"10", "ten"}
]

for {k, v} <- pairs do
  RedisCluster.Cluster.set(config, k, v)
  slot = RedisCluster.Key.hash_slot(k)
  IO.puts("{#{k}, #{v}} => #{slot}")
end
```

<!-- livebook:{"output":true} -->

```
{1, one} => 9842
{2, two} => 5649
{3, three} => 1584
{4, four} => 14039
{5, five} => 9974
{6, six} => 5781
{7, seven} => 1716
{8, eight} => 14171
{9, nine} => 10106
{10, ten} => 247
```

<!-- livebook:{"output":true} -->

```
[:ok, :ok, :ok, :ok, :ok, :ok, :ok, :ok, :ok, :ok]
```

```elixir
config
|> RedisCluster.Cluster.broadcast([~w[DBSIZE]], role: :master)
|> Enum.sort()
```

<!-- livebook:{"output":true} -->

```
[
  {"127.0.0.1", 6379, :master, {:ok, [3]}},
  {"127.0.0.1", 6381, :master, {:ok, [4]}},
  {"127.0.0.1", 6387, :master, {:ok, [5]}}
]
```

As long as only the above 10 keys have been written to this cluster, there will be 2 nodes with 2 keys and 2 nodes with 3 keys. That's as even as it gets for such a small set of keys.

## Hash Tags

Next, let's look at a caveat with Redis clusters. Previously, we saw that keys 1, 5, and 9 are on the same node (range 8192-12,287).
So that means we should be able to fetch them in one request with [MGET](https://redis.io/docs/latest/commands/mget/), right?

```elixir
RedisCluster.Cluster.command(config, ~w[MGET 1 5 9], "1", [])
```

<!-- livebook:{"output":true} -->

```
{:error, %Redix.Error{message: "CROSSSLOT Keys in request don't hash to the same slot"}}
```

Wrong. We get the error `CROSSSLOT Keys in request don't hash to the same slot`. 
This means that the keys must hash to the exact value, even if they happen to live on the same node.
With hashes randomly distributed, there's only 1:16,384 change that any two arbitrary keys have the same hash slot. 
So, it seems that we can't use MGET, right?

Wrong. There is a viable option. We can use hash tags.

A hash tag specifies a subset of the key to use for calculating the hash slot. 
Specifically, the first substring surrounded with braces (`{...}`).
It looks like this:

```elixir
keys = [
  "{user1234}:orders",
  "{user1234}:search_history",
  "{user1234}:contact_info",
]

for key <- keys do
  RedisCluster.Key.hash_slot(key, compute_hash_tag: true)
end
```

<!-- livebook:{"output":true} -->

```
[14020, 14020, 14020]
```

All three keys have the same hash slot: 14,020. 
This is the same as if you calculated the hash slot of `user1234`.

```elixir
RedisCluster.Key.hash_slot("user1234")
```

<!-- livebook:{"output":true} -->

```
14020
```

Notice the extra `:compute_hash_tag` option.
The `RedisCluster` library doesn't look for a hash tag unless you request it. 
This avoids any unnecessary overhead if you don't use hash tags.

Also, note that it doesn't matter where in the key the hash tag appears.

```elixir
keys = [
  "orders:{user1234}",
  "search_history:{user1234}",
  "contact_info:{user1234}",
]

for key <- keys do
  RedisCluster.Key.hash_slot(key, compute_hash_tag: true)
end
```

<!-- livebook:{"output":true} -->

```
[14020, 14020, 14020]
```

You can also confirm this behavior by calling the [`CLUSTER KEYSLOT <key>` command](https://redis.io/docs/latest/commands/cluster-keyslot/).

```elixir
for key <- keys do
  RedisCluster.Cluster.command(config, ["CLUSTER", "KEYSLOT", key], "arbitrary", [])
end
```

<!-- livebook:{"output":true} -->

```
[14020, 14020, 14020]
```

You'll notice the extra `:key` option. This helps the `RedisCluster` library know which node to call.
Though in this case it doesn't matter. 
Any node receiving this command can respond appropriately. 
The node isn't looking up the data, it's just computing the slot.

<!-- livebook:{"break_markdown":true} -->

Let's try `MGET` again.

```elixir
set_cmd =  ~w/MSET {user1234}:orders "[]" {user1234}:search_history ["redis"] {user1234}:contact_info [test@example.com]/
RedisCluster.Cluster.command(config, set_cmd, "user1234", compute_hash_tag: true)

get_cmd = ~w[MGET {user1234}:contact_info {user1234}:orders {user1234}:search_history]
RedisCluster.Cluster.command(config, get_cmd, "user1234", compute_hash_tag: true)
```

<!-- livebook:{"output":true} -->

```
["[test@example.com]", "\"[]\"", "[\"redis\"]"]
```

### Binary Keys

You can use binary data as a key. 
However, you need to watch out for the rare chance you have a `{` character (hex `0x7B`)) followed by a `}` character (hex `0x7C`). 
Because of this, it's recommended to prepend `{}` to the start of your key.
When an empty hash tag is found, the full key is always used.

```elixir
binary_key = "{}" <> <<0xDE, 0xAD, 0xBE, 0xEF>>
RedisCluster.Key.hash_slot(binary_key, compute_hash_tag: true)
```

<!-- livebook:{"output":true} -->

```
16021
```

```elixir
cmd = ["CLUSTER", "KEYSLOT", binary_key]
RedisCluster.Cluster.command(config, cmd, binary_key, compute_hash_tag: true)
```

<!-- livebook:{"output":true} -->

```
16021
```

### Hash Data Type

Instead of using hashtags to ensure related data is stored on the same node, you can use a Hash. The Redis folks must really love the word "hash". A Hash is also known as a hash table, map, or dictionary.

```elixir
set_cmd =  ~w/HSET user1234 orders "[]" search_history ["redis"] contact_info [test@example.com]/
RedisCluster.Cluster.command(config, set_cmd, "user1234", [])
```

<!-- livebook:{"output":true} -->

```
3
```

```elixir
RedisCluster.Cluster.command(config, ~w[HKEYS user1234], "user1234", [])
```

<!-- livebook:{"output":true} -->

```
["orders", "search_history", "contact_info"]
```

```elixir
RedisCluster.Cluster.command(config, ~w[HGET user1234 search_history], "user1234", [])
```

<!-- livebook:{"output":true} -->

```
"[\"redis\"]"
```

Redis supports other data types such as 
[lists](https://redis.io/docs/latest/commands/?group=list), 
[sets](https://redis.io/docs/latest/commands/?group=set), 
[sorted sets](https://redis.io/docs/latest/commands/?group=sorted-set), 
[lua scripts](https://redis.io/docs/latest/commands/?group=scripting), 
[bloom filters](https://redis.io/docs/latest/commands/?group=bf), and more.
Check them out in the [docs](https://redis.io/docs/latest/).

## Discovery

So, how does the `RedisCluster` library know which node to send a command to?
This is where the node discovery process comes in. 
The `RedisCluster` library is configured with a URL to connect to a node. 
Ideally this URL should be a "configuration endpoint" as AWS ElastiCache calls it.
The configuration endpoint picks a random node to connect to. 
This ensures one node isn't being hit every time the cluster needs to be discovered.

The `RedisCluster` library sends a [`CLUSTER SHARDS` command](https://redis.io/docs/latest/commands/cluster-shards/)
to the connected node. 
Or for pre-v7 nodes, the [`CLUSTER SLOTS` command](https://redis.io/docs/latest/commands/cluster-slots/).

```elixir
RedisCluster.Cluster.command(config, ~w[CLUSTER SHARDS], "arbitrary", [])
```

<!-- livebook:{"output":true} -->

```
[
  [
    "slots",
    [10923, 16383],
    "nodes",
    [
      ["id", "1ec0c4e7b0e1c1e79f8e54fd495f26eeab51c18a", "port", 6381, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "master", "replication-offset", 66045, "health", "online"],
      ["id", "b4d324d3ae0415a1c7a0ad53b37d352a0e8ed926", "port", 6385, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 66045, "health", "online"],
      ["id", "a203a6d39540085e2de808d67fdc688fb0604375", "port", 6390, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 66045, "health", "online"],
      ["id", "e5492ebe6b2a43008dd9ec01f004dd1064e98306", "port", 6384, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 66045, "health", "online"]
    ]
  ],
  [
    "slots",
    [5461, 10922],
    "nodes",
    [
      ["id", "2d0bc4aa9e9e4f2fd78ac9a5ed6df17f8c8bff21", "port", 6380, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 64094, "health", "online"],
      ["id", "1400892e8e5134a307bb37e803118dbb5e8c60f0", "port", 6382, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 64094, "health", "online"],
      ["id", "54f1a29e06bc1bb87becae4604e56e61c9fcab92", "port", 6383, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 64094, "health", "online"],
      ["id", "10d604d4b775205badc3b497d226cf998a67862a", "port", 6387, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "master", "replication-offset", 64094, "health", "online"]
    ]
  ],
  [
    "slots",
    [0, 5460],
    "nodes",
    [
      ["id", "07e3568cd06965675c9341cb8ae75666b797ba88", "port", 6379, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "master", "replication-offset", 63690, "health", "online"],
      ["id", "982bef4e8adbf4a3d514551e716ddae191e857fb", "port", 6389, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 63690, "health", "online"],
      ["id", "dac5b647f43ccfd8d0db633188d086178dd65a1e", "port", 6386, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 63690, "health", "online"],
      ["id", "37bcb25848d4bfa0381bd6b32e875a7230df0925", "port", 6388, "ip", "127.0.0.1",
       "endpoint", "127.0.0.1", "role", "replica", "replication-offset", 63690, "health", "online"]
    ]
  ]
]
```

That's quite a bit of data to sift through. 
You can see it in a nicer form with `RedisCluster.HashSlots.all_slots/1`.

```elixir
config
|> RedisCluster.HashSlots.all_slots()
|> Enum.sort()
```

<!-- livebook:{"output":true} -->

```
[
  {RedisCluster.HashSlots, 0, 5460, :master, "127.0.0.1", 6379},
  {RedisCluster.HashSlots, 0, 5460, :replica, "127.0.0.1", 6386},
  {RedisCluster.HashSlots, 0, 5460, :replica, "127.0.0.1", 6388},
  {RedisCluster.HashSlots, 0, 5460, :replica, "127.0.0.1", 6389},
  {RedisCluster.HashSlots, 5461, 10922, :master, "127.0.0.1", 6387},
  {RedisCluster.HashSlots, 5461, 10922, :replica, "127.0.0.1", 6380},
  {RedisCluster.HashSlots, 5461, 10922, :replica, "127.0.0.1", 6382},
  {RedisCluster.HashSlots, 5461, 10922, :replica, "127.0.0.1", 6383},
  {RedisCluster.HashSlots, 10923, 16383, :master, "127.0.0.1", 6381},
  {RedisCluster.HashSlots, 10923, 16383, :replica, "127.0.0.1", 6384},
  {RedisCluster.HashSlots, 10923, 16383, :replica, "127.0.0.1", 6385},
  {RedisCluster.HashSlots, 10923, 16383, :replica, "127.0.0.1", 6390}
]
```

If the `RedisCluster.Cluster` module sends a command and sees a `MOVED` error, ex. `MOVED 3720 127.0.0.1:7000`, then it assumes the cluster topology changed.
It then tries to rediscover the cluster.
For most commands it will retry the command once more.
If it fails again, then there could be a problem with the cluster or the connection to it.

Ideally a node will only have one range of slots. 
However, adding and removing nodes can cause the ranges to become fragmented.
The `RedisCluster` library is smart enough to detect this. 
It creates connections based on the nodes, not the hash ranges.

<!-- livebook:{"break_markdown":true} -->

### Lookup

Knowing which nodes own which slots, the `RedisCluster` library is ready to look up the appropriate node.
This is the process:

1. Hash the key, account for hashtag when appropriate.
2. Look up the nodes that own this hash slot.
3. Filter nodes by role, if needed.
4. Pick a node, if more than one option available.
5. Grab a connection from the node's connection pool.

Note that when the `RedisCluster` library picks a node and connection it does so consistently per process.
It does this with a simple hash of the pid, modulo the node or connection count.

<!-- livebook:{"force_markdown":true} -->

```elixir
index = :erlang.phash2(self(), count)
```

## Using RedisCluster

The prior examples used `RedisCluster.Cluster` directly. 
Though you will likely interact with it using a custom module. 
Start with adding your config. 
This could be in `config.exs` but more likely you will use env vars in `runtime.exs`.

```elixir
Application.put_all_env(myapp: [{MyApp.Redis, [host: "localhost", port: 7000, pool_size: 3]}])
```

<!-- livebook:{"output":true} -->

```
:ok
```

Then you create your own module that uses the `RedisCluster` module.
The `config()` function is available for convenience.

```elixir
defmodule MyApp.Redis do
  use RedisCluster, otp_app: :myapp

  def hset(key, pairs) do
    pairs = Enum.flat_map(pairs, fn {k, v} -> [k, v] end)
    cmd = ["HSET", key | pairs]

    RedisCluster.Cluster.command(config(), cmd, key, [])
  end

  def hkeys(key) do
    RedisCluster.Cluster.command(config(), ["HKEYS", key], key, [])
  end

  def hget(key, field) do
    RedisCluster.Cluster.command(config(), ["HGET", key, field], key, [])
  end

  def hdel(_key, []) do
    0
  end

  def hdel(key, fields) do
    RedisCluster.Cluster.command(config(), ["HDEL", key | fields], key, [])
  end
end
```

<!-- livebook:{"output":true} -->

```
{:module, MyApp.Redis, <<70, 79, 82, 49, 0, 0, 40, ...>>, {:hdel, 2}}
```

The `RedisCluster` module will automatically add common functions such as `get/2`, `set/3`, `command/2`, and `pipeline/2`. 
Redis has over 200 commands.
You can add your own convenience functions depending on which Redis commands your application needs.
Notice the above module adds `hset/2`, `hkeys/1`, and `hget/2`.

```elixir
RedisCluster.Cluster.command(config, ~w[COMMAND COUNT], "anything", [])
```

<!-- livebook:{"output":true} -->

```
265
```

Don't forget to add your module to your supervision tree.
For this Livebook we'll start it directly.

```elixir
case MyApp.Redis.start_link([]) do
  {:ok, pid} -> pid
  {:error, {:already_started, pid}} -> pid
end
```

<!-- livebook:{"output":true} -->

```

11:23:02.997 [debug] Discovering shards for Elixir.MyApp.Redis

```

<!-- livebook:{"output":true} -->

```
#PID<0.438.0>
```

<!-- livebook:{"output":true} -->

```

11:23:03.004 [debug] Found cluster info
Slot Start | Slot End | Host      | Port | Role    | Health
---------- | -------- | --------- | ---- | ------- | ------
0          | 5460     | 127.0.0.1 | 7000 | replica | online
0          | 5460     | 127.0.0.1 | 7003 | replica | online
0          | 5460     | 127.0.0.1 | 7006 | master  | online
0          | 5460     | 127.0.0.1 | 7010 | replica | online
0          | 5460     | 127.0.0.1 | 7011 | replica | online
5461       | 10922    | 127.0.0.1 | 7001 | replica | online
5461       | 10922    | 127.0.0.1 | 7007 | replica | online
5461       | 10922    | 127.0.0.1 | 7009 | master  | online
10923      | 16383    | 127.0.0.1 | 7002 | replica | online
10923      | 16383    | 127.0.0.1 | 7004 | master  | online
10923      | 16383    | 127.0.0.1 | 7005 | replica | online
10923      | 16383    | 127.0.0.1 | 7008 | replica | online

```

From here you can call it directly. 
Notice how much nicer the Hash data type is to work with using the convenience functions we added.

```elixir
MyApp.Redis.hset("myhash", %{a: "1", b: "2", c: "3"})
```

<!-- livebook:{"output":true} -->

```
3
```

```elixir
MyApp.Redis.hkeys("myhash")
```

<!-- livebook:{"output":true} -->

```
["c", "b", "a"]
```

```elixir
MyApp.Redis.hget("myhash", "a")
```

<!-- livebook:{"output":true} -->

```
"1"
```

```elixir
MyApp.Redis.hdel("myhash", ~w[a b c])
```

<!-- livebook:{"output":true} -->

```
3
```

```elixir
MyApp.Redis.hget("myhash", "a")
```

<!-- livebook:{"output":true} -->

```
nil
```

The `RedisCluster.Cluster` module also has `get_many/2`, `set_many/2`, and `delete_many/2` functions.
These are not one-to-one mappings with the 
[`MGET`](https://redis.io/docs/latest/commands/mget/), 
[`MSET`](https://redis.io/docs/latest/commands/mset/), and 
[`DEL`](https://redis.io/docs/latest/commands/del/) commands.

Instead `RedisCluster` tries to be smarter by grouping commands by nodes and sending them in a batch pipeline.
These commands will fail if the cluster reshards while the commands are in flight.
The commands are also sent to each node sequentially for simplicity. 
This may not be as fast as sending the commands in parallel

```elixir
MyApp.Redis.set_many(one: 1, two: 2, three: 3, four: 4, five: 5, six: 6)
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
MyApp.Redis.get_many(~w[six five four three two one])
```

<!-- livebook:{"output":true} -->

```
["6", "5", "4", "3", "2", "1"]
```

```elixir
MyApp.Redis.delete_many(~w[six five four three two one])
```

<!-- livebook:{"output":true} -->

```
6
```

```elixir
MyApp.Redis.get_many(~w[six five four three two one])
```

<!-- livebook:{"output":true} -->

```
[nil, nil, nil, nil, nil, nil]
```

## Read Replicas

Unlike other Elixir Redis libraries, the `RedisCluster` library gives you full access to replica nodes.
This allows your Redis cluster to scale better.

Write commands **must** go to a master node.

```elixir
MyApp.Redis.command(~w[SET fail fail], "fail", role: :replica)
```

<!-- livebook:{"output":true} -->

```
{:error, %Redix.Error{message: "MOVED 3720 127.0.0.1:7006"}}
```

Writing to a replica gives an error like `MOVED 3720 127.0.0.1:7000`.
In this case the replica node is redirecting you to its respective master node.

By default, the `get/2` function sends the `GET` command to a replica. 
Though you can specify it to go to a master node if you don't want any chance of stale data.

```elixir
MyApp.Redis.set("key", "value")
MyApp.Redis.get("key", role: :master)
```

<!-- livebook:{"output":true} -->

```
"value"
```

Or if you don't care which node it goes to, then you can specify `:any`.

```elixir
MyApp.Redis.get("key", role: :any)
```

<!-- livebook:{"output":true} -->

```
"value"
```

## Async Commands

Some of the provided commands can be run in parallel:

* `get_many_async`
* `set_many_async`
* `delete_many_async`
* `broadcast_async`

These commands will send requests in parallel up to the given concurrency limit.

```elixir
RedisCluster.Cluster.set_many_async(config, %{a: 1, b: 2, c: 3}, role: :master, max_concurrency: 2)
```

<!-- livebook:{"output":true} -->

```
:ok
```

```elixir
RedisCluster.Cluster.get_many_async(config, ~w[a b c], role: :master, max_concurrency: 2)
```

<!-- livebook:{"output":true} -->

```
["1", "2", "3"]
```

```elixir
RedisCluster.Cluster.delete_many_async(config, ~w[a b c], role: :master, max_concurrency: 2)
```

<!-- livebook:{"output":true} -->

```
3
```

```elixir
RedisCluster.Cluster.get_many_async(config, ~w[a b c], role: :master, max_concurrency: 2)
```

<!-- livebook:{"output":true} -->

```
[nil, nil, nil]
```

```elixir
config
|> RedisCluster.Cluster.broadcast_async([~w[PING], ~w[TIME], ~w[DBSIZE]], role: :master)
|> Enum.sort()
```

<!-- livebook:{"output":true} -->

```
[
  {"127.0.0.1", 6379, :master, {:ok, ["PONG", ["1754674111", "280663"], 3]}},
  {"127.0.0.1", 6381, :master, {:ok, ["PONG", ["1754674111", "275772"], 8]}},
  {"127.0.0.1", 6387, :master, {:ok, ["PONG", ["1754674111", "278652"], 5]}}
]
```

```elixir
config
|> RedisCluster.Cluster.broadcast_async([~w[PING], ~w[TIME], ~w[DBSIZE]], role: :any)
|> Enum.sort()
```

<!-- livebook:{"output":true} -->

```
[
  {"127.0.0.1", 6379, :master, {:ok, ["PONG", ["1754674159", "101254"], 3]}},
  {"127.0.0.1", 6380, :replica, {:ok, ["PONG", ["1754674159", "101561"], 5]}},
  {"127.0.0.1", 6381, :master, {:ok, ["PONG", ["1754674159", "101611"], 8]}},
  {"127.0.0.1", 6382, :replica, {:ok, ["PONG", ["1754674159", "101538"], 5]}},
  {"127.0.0.1", 6383, :replica, {:ok, ["PONG", ["1754674159", "101487"], 5]}},
  {"127.0.0.1", 6384, :replica, {:ok, ["PONG", ["1754674159", "101688"], 8]}},
  {"127.0.0.1", 6385, :replica, {:ok, ["PONG", ["1754674159", "101658"], 8]}},
  {"127.0.0.1", 6386, :replica, {:ok, ["PONG", ["1754674159", "101444"], 3]}},
  {"127.0.0.1", 6387, :master, {:ok, ["PONG", ["1754674159", "101504"], 5]}},
  {"127.0.0.1", 6388, :replica, {:ok, ["PONG", ["1754674159", "101403"], 3]}},
  {"127.0.0.1", 6389, :replica, {:ok, ["PONG", ["1754674159", "101351"], 3]}},
  {"127.0.0.1", 6390, :replica, {:ok, ["PONG", ["1754674159", "101601"], 8]}}
]
```
